---
title: "contourr"
author: "Kaitlyn Strickfaden"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{contourr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<br>

```{r, include = FALSE}
knitr::opts_chunk$set(
  fig.width = 8,
  fig.height = 6,
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = F}
library(imager)
library(dplyr)
library(qpdf)
```

<br>

#  The Virtual Snow Stake

The `contourr` package provides a simple method for extracting the outlines of an object of interest in one image and overlaying the same outlines onto new images. This vignette is a step-by-step description of the methodology.

<br>

Right now, this package includes three functions:

- `ct_find`: find and recolor outlines in just one image, with the option to save the output image. Useful for tinkering with contour values until you find the right one for your image.
- `ct_cvdf`: an interactive function to help you find the right contour values for multiple images and then save those contour values in a data frame.
- `ct_overlay`: find and recolor outlines in one image, then overlay those outlines onto a set of other images.

<br>

It's really important that the object you want to extract contrasts with the background. If the image is overexposed or underexposed, or if the object is a similar color to the background, the method described below won't work.

<br>

---

<br>

## Methodology

<br>

This code uses the package `imager`, which is one of few image processing packages in R. This particular package has some handy built-in functions that we will be using to save a little time and computing power.

<br>

Let's take a look at an image using `imager`'s "load.image" function. I'll also convert it into a dataframe and give each pixel a unique index to make it easier to manipulate later.

<br>

```{r load image 1}
im1 <- load.image("../images/image01.jpg")
im1_df <- as.data.frame(im1)
im1_df$id <- rep(1:(dim(im1)[1] * dim(im1)[2]), times = 3)
plot(im1)
```

<br>

A color image is the combined result of three layers of pixels, one layer each for red, green, and blue shades, which are plotted below for reference. R "plots" an image by assigning a combination of red, green, and blue values to each pixel coordinate, with indexing starting in the upper left-hand corner. This image is 384 pixels wide and 256 pixels high.

<br>

```{r rgb image}
red <- im1
red[,,,c(2:3)] <- c(0,0)

green <- im1
green[,,,c(1,3)] <- c(0,0)

blue <- im1
blue[,,,1:2] <- c(0,0)

par(mfrow = c(1,3), mar = c(.1,.1,.1,.1))
plot(red, axes = F)
plot(green, axes = F)
plot(blue, axes = F)
```
<br>

Color images can be converted to grayscale. There are about a million ways to convert a color image to grayscale, but `imager` converts the luminance (brightness) of a pixel into a shade of gray. Let's see what that looks like for our image:

<br>

```{r grayscale image 1}
plot(grayscale(im1), axes = F)
```

<br>

Now we have a black and white version of our image. This is the image from which we will extract contours.

<br>

A contour is just an edge in an image; the `imgradient` function in `imager` compares the value of one pixel to the values of the pixels immediately around it. Greater differences between neighboring pixels will give a pixel a larger contour value, while weaker differences will give a smaller contour value. Images have x contours and y contours, which look like this:

<br>

```{r xy contours}
par(mar = c(1,.1,1,.1))
im1_xy <- imgradient(grayscale(im1), "xy")
plot(im1_xy, layout = "row", axes = F)
```

<br>

Next, we'll find the distance between the values in the x contour plot and the values in the y contour plot at each pixel coordinate. When either x or y are a contour, there is a greater distance between the two values. Normalizing these distances lets us give greater weight to places in the image where there are contours. `imager` has a function called `enorm` which does these calculations for us. When we find the distances between the pixels in the x and y contour plots, the result is a single image which looks like this:

<br>

```{r contour image}
im1_gr <- enorm(imgradient(grayscale(im1),"xy"))
im1_bw <- as.data.frame(im1_gr)
im1_bw$id <- 1:length(im1_bw$x) 
plot(im1_gr, axes = F)
```

<br>

This is the image upon which this methodology stands. Love it, respect it, cherish it. Also, save it as a data frame, because we'll need it later.

<br>

---

<br>

## Define a Region of Interest

<br>

We don't necessarily want to find *every* contour in an image; in my case, I only want the contours of the measuring stake. Fortunately, `imager` has functions that allow you to output the coordinates of particular points, lines, or rectangles that you draw on an image. This lets us limit our search for contours to just a region we care about.

<br>

The package will allow you to draw in a region of interest using the "grabRect" function. I define my region of interest...

<br>

```{r rectangle grab}
#im_c <- grabRect(im1, output = "coord") # draw a box around the object of interest
im_c <- c(316,47,389,713)
plot(im1, axes = F)
rect(im_c[1], im_c[2], im_c[3], im_c[4], border = "cyan1")
```

<br>

And then filter out the pixels outside of this box so R isn't dealing with so much data.

```{r filter 1}
roi <- filter(im1_bw,
              im1_bw$x >= im_c[1] & im1_bw$x <= im_c[3] &
              im1_bw$y >= im_c[2] & im1_bw$y <= im_c[4])
```

<br>

`ct_find` and `ct_overlay` both allow you to set the number of regions so you can define several regions of interest if you need. `ct_overlay` even lets you find regions in multiple images!

<br>

---

<br>

## Highlight the Contours in An Image 

<br>

This next code chunk will find the coordinates of the contours in the contour image and recolor them in the original image. You must specify some contour value as the minimum threshold to keep. By trial and error, I found that 0.1 was a good `contourvalue` for this image.

<br>

```{r recolor image 1}
## Find contours in region of interest

roi_cv <- roi[roi$value >= .1,]

## Find contour pixels in full image

m <- im1_df$id[match(roi_cv$id, im1_df$id)]

## Recolor contour pixels in full image

rgbcolor <- col2rgb("cyan1")/255

im1_df$value[im1_df$id %in% m] <- rep(rgbcolor, each = length(m))
```

<br>

What's the result?

<br>

```{r plot recolored image 1}
im1_new <- as.cimg(im1_df, dim = dim(im1)) 
plot(im1_new, axes = F)
```

<br>

Now we have the original image with the contours of the measuring stake highlighted. We also know the coordinates of those pixels. Let's have `contourr` shift the recolored pixels over so we can draw a second measuring stake onto our original image.

<br>

```{r load image 2, echo = F}
im2 <- load.image("../images/image02.jpg")
im2_df <- as.data.frame(im2) 
im2_df$id <- 1:length(im1_bw$x)
plot(im2, axes = F)
```

<br>

You can input a vector with two values, the first being the shift on the x-plane and the second being the shift on the y-plane. Let's have `contourr` shift the snow stake 300 pixels to the right.

<br>

```{r recolor set shift}

shift <- c(300,0)  

```

```{r recolor image 2, echo = F}
## Recolor contour pixels in full image

x_shift <- shift[1]
y_shift <- -shift[2]

  m_df <- im2_df[match(roi_cv$id, im2_df$id),]
  m_df$keep <- "Y"

  for (i in seq_along(m_df$id)) {

    if (m_df$x[i] + x_shift > dim(im2)[1]) {
      m_df$keep[i] <- "N" }
    if (m_df$x[i] + x_shift < 0) {
      m_df$keep[i] <- "N" }
    if (m_df$y[i] + y_shift > dim(im2)[2]) {
      m_df$keep[i] <- "N" }
    if (m_df$y[i] + y_shift < 0) {
      m_df$keep[i] <- "N" }

  }

  m <- m_df$id[m_df$keep == "Y"] + x_shift + (y_shift * dim(im2)[2])
  
im2_df$value[im2_df$id %in% m] <- rep(rgbcolor, each = length(m))

im2_new <- as.cimg(im2_df, dim = dim(im2))
plot(im2_new, axes = F)
```

<br>

Cool! Now we've drawn a measuring stake next to the real one. Of course, you don't have to do any shifting at all if you don't need to; the default is to draw the virtual measuring stake in exactly the same position as it was in that first image. But this option makes it possible for the user to move the virtual measuring stake in case the camera viewshed changes during deployment. 

<br>

So what happens if the image you have doesn't jave ideal lighting conditions?

```{r load image 3, echo = F}
im3 <- load.image("../images/image03.jpg")
im3_df <- as.data.frame(im3) 
im3_df$id <- 1:length(im1_bw$x)
plot(im3, axes = F)
```

```{r contour image 3, echo = F}
im3_gr <- enorm(imgradient(grayscale(im3),"xy"))
im3_bw <- as.data.frame(im3_gr)
im3_bw$id <- 1:length(im3_bw$x) 

roi <- filter(im3_bw,
              im3_bw$x >= im_c[1] & im3_bw$x <= im_c[3] &
              im3_bw$y >= im_c[2] & im3_bw$y <= im_c[4])

roi_cv <- roi[roi$value >= .05,]

m_df <- im3_df[match(roi_cv$id, im3_df$id),]
m_df$keep <- "Y"

for (i in seq_along(m_df$id)) {

  if (m_df$x[i] + x_shift > dim(im3)[1]) {
    m_df$keep[i] <- "N" }
  if (m_df$x[i] + x_shift < 0) {
    m_df$keep[i] <- "N" }
  if (m_df$y[i] + y_shift > dim(im3)[2]) {
    m_df$keep[i] <- "N" }
  if (m_df$y[i] + y_shift < 0) {
    m_df$keep[i] <- "N" }

}

m <- m_df$id[m_df$keep == "Y"] + x_shift + (y_shift * dim(im3)[2])
  
im3_df$value[im3_df$id %in% m] <- rep(rgbcolor, each = length(m))

im3_new <- as.cimg(im3_df, dim = dim(im3))
plot(im3_new, axes = F)

```
<br>

When the image is over- or under-exposed, you'll probably have a much harder time finding a threshold value that gives you good results.

---

<br>

## Other Applications

<br>

This package, or at least this methodology, will likely be useful for many camera applications which require some reference object. For instance, someone who was interested in being able to measure how far away animals are from cameras might be able to overlay a grid onto images. Or, someone who was interested in measuring the animals themselves might be able to use a similar method to mine.

<br>





